<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced Pattern Detection</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family: Arial,sans-serif; background: linear-gradient(135deg,#667eea,#764ba2); min-height:100vh; padding:20px; }
.container { max-width:1400px; margin:0 auto; background:white; border-radius:15px; padding:30px; box-shadow:0 10px 30px rgba(0,0,0,0.2); }
h1 { text-align:center; color:#333; margin-bottom:10px; }
.subtitle { text-align:center; color:#666; font-size:14px; margin-bottom:30px; }

.input-section { background:#f8f9fa; padding:25px; border-radius:10px; border:2px solid #e9ecef; margin-bottom:25px; }
.section-title { color:#333; margin-bottom:20px; font-size:18px; font-weight:bold; }
.data-input { margin-bottom:20px; }
.data-input textarea { width:100%; height:300px; padding:15px; border:2px solid #ddd; border-radius:8px; font-size:14px; resize:vertical; font-family:monospace; line-height:1.5; }
.data-input textarea:focus { border-color:#667eea; outline:none; }
.button-group { display:flex; gap:15px; margin-bottom:20px; }
button { flex:1; padding:15px; border:none; border-radius:8px; font-size:16px; font-weight:bold; cursor:pointer; transition:all 0.3s; }
.btn-analyze { background:#2196F3;color:white; }
.btn-clear { background:#f44336;color:white; }
button:hover { opacity:0.9; transform:translateY(-2px); }
.info { background:#e3f2fd; padding:15px; border-radius:8px; margin-bottom:20px; text-align:center; }

.results-section { background:#f8f9fa; padding:25px; border-radius:10px; border:2px solid #e9ecef; }
.result-item { margin-bottom:20px; padding:15px; background:white; border-radius:8px; border:1px solid #e0e0e0; }
.result-valid { border-left:4px solid #4CAF50; }
.result-invalid { border-left:4px solid #ff9800; }
.pattern-details { margin-top:10px; padding:10px; background:#f5f5f5; border-radius:5px; font-size:12px; }
.progress { margin:10px 0; height:20px; background:#e0e0e0; border-radius:10px; overflow:hidden; }
.progress-bar { height:100%; background:#4CAF50; transition:width 0.3s; }
</style>
</head>
<body>
<div class="container">
    <h1>üîç ADVANCED PATTERN DETECTION</h1>
    <div class="subtitle">Analisis Pattern Otomatis & Komprehensif</div>
    
    <div class="input-section">
        <div class="section-title">üì• INPUT DATA</div>
        
        <div class="data-input">
            <textarea id="inputData" placeholder="Masukkan data dalam format:&#10;angka = hasil&#10;6874 = 94&#10;0489 = 83&#10;2843 = 72&#10;...">6874 = 94
0489 = 83
2843 = 72
3752 = 49
8644 = 16
2962 = 72
6937 = 50
0559 = 49
8445 = 49
2429 = 49
5879 = 05
9158 = 61
5364 = 50
2190 = 38
3358 = 05</textarea>
        </div>
        
        <div class="button-group">
            <button class="btn-analyze" onclick="analyzePattern()">üîç ANALISIS PATTERN</button>
            <button class="btn-clear" onclick="clearAll()">üóëÔ∏è CLEAR</button>
        </div>
        
        <div class="info" id="info">Masukkan data, lalu klik ANALISIS PATTERN</div>
        <div class="progress" id="progressBar" style="display:none;">
            <div class="progress-bar" id="progressFill" style="width:0%"></div>
        </div>
    </div>

    <div class="results-section" id="resultsSection" style="display:none;">
        <div class="section-title">üìä HASIL ANALISIS</div>
        <div id="resultsContainer"></div>
    </div>
</div>

<script>
function analyzePattern() {
    const inputData = document.getElementById('inputData').value.trim();
    
    if (!inputData) {
        showInfo('Masukkan data terlebih dahulu!', 'error');
        return;
    }
    
    try {
        showInfo('Memulai analisis pattern...', 'info');
        document.getElementById('progressBar').style.display = 'block';
        updateProgress(0);
        
        // Parse data
        const parsedData = parseInputData(inputData);
        
        if (parsedData.length < 4) {
            showInfo(`Minimal 4 data required. Hanya ${parsedData.length} data.`, 'error');
            return;
        }
        
        // Analisis pattern untuk setiap digit
        setTimeout(() => {
            const results = comprehensivePatternAnalysis(parsedData);
            displayResults(results);
            showInfo('Analisis pattern selesai!', 'success');
        }, 100);
        
    } catch (error) {
        showInfo(`Error: ${error.message}`, 'error');
    }
}

function parseInputData(inputData) {
    const lines = inputData.split('\n').filter(line => line.trim());
    const parsedData = [];
    
    for (let line of lines) {
        const match = line.match(/^(\d+)\s*=\s*(\d+)\s*$/);
        if (match) {
            const number = match[1];
            const result = match[2];
            
            parsedData.push({
                number: number,
                result: result,
                digits: result.split('').map(d => parseInt(d))
            });
        }
    }
    
    return parsedData;
}

function comprehensivePatternAnalysis(parsedData) {
    const digitLength = parsedData[0].digits.length;
    const results = [];
    
    updateProgress(10);
    
    // Analisis untuk setiap digit
    for (let digitIndex = 0; digitIndex < digitLength; digitIndex++) {
        const analysis = analyzeDigitPattern(parsedData, digitIndex);
        results.push(analysis);
        updateProgress(10 + (digitIndex + 1) * 30);
    }
    
    // Analisis pattern sequence
    updateProgress(80);
    const sequenceAnalysis = analyzeSequencePattern(parsedData);
    results.push(sequenceAnalysis);
    
    updateProgress(100);
    
    return {
        digitAnalyses: results.slice(0, digitLength),
        sequenceAnalysis: results[digitLength],
        summary: generateSummary(results.slice(0, digitLength))
    };
}

function analyzeDigitPattern(parsedData, digitIndex) {
    const naikValues = [];
    const details = [];
    
    // Kumpulkan semua nilai "naik"
    for (let i = 0; i < parsedData.length - 1; i++) {
        const current = parsedData[i].digits[digitIndex];
        const next = parsedData[i + 1].digits[digitIndex];
        const naik = (next - current + 10) % 10;
        
        naikValues.push(naik);
        details.push({
            from: parsedData[i].number,
            to: parsedData[i + 1].number,
            current: current,
            next: next,
            naik: naik
        });
    }
    
    // Multiple analysis methods
    const analyses = [
        analyzeExactMatch(naikValues),
        analyzeModus(naikValues),
        analyzeCyclePattern(naikValues, 2),
        analyzeCyclePattern(naikValues, 3),
        analyzeCyclePattern(naikValues, 4),
        analyzeAlternatingPattern(naikValues)
    ];
    
    // Pilih analysis terbaik
    const bestAnalysis = analyses.reduce((best, current) => {
        return current.confidence > best.confidence ? current : best;
    });
    
    return {
        digit: digitIndex + 1,
        naikValues: naikValues,
        details: details,
        bestPattern: bestAnalysis,
        allAnalyses: analyses
    };
}

function analyzeExactMatch(naikValues) {
    const allSame = naikValues.every(val => val === naikValues[0]);
    return {
        method: 'Exact Match',
        pattern: naikValues[0],
        confidence: allSame ? 100 : 0,
        details: allSame ? 
            `Semua nilai sama: ${naikValues[0]}` :
            'Tidak semua nilai sama'
    };
}

function analyzeModus(naikValues) {
    const frequency = {};
    naikValues.forEach(val => frequency[val] = (frequency[val] || 0) + 1);
    
    let maxCount = 0;
    let bestValue = naikValues[0];
    for (const [value, count] of Object.entries(frequency)) {
        if (count > maxCount) {
            maxCount = count;
            bestValue = parseInt(value);
        }
    }
    
    const confidence = (maxCount / naikValues.length) * 100;
    
    return {
        method: 'Modus',
        pattern: bestValue,
        confidence: confidence,
        details: `Nilai ${bestValue} muncul ${maxCount} dari ${naikValues.length} kali (${confidence.toFixed(1)}%)`
    };
}

function analyzeCyclePattern(naikValues, cycleLength) {
    if (naikValues.length < cycleLength * 2) {
        return {
            method: `Cycle ${cycleLength}`,
            pattern: null,
            confidence: 0,
            details: `Data tidak cukup untuk cycle ${cycleLength}`
        };
    }
    
    let matchCount = 0;
    const cycles = [];
    
    for (let i = 0; i <= naikValues.length - cycleLength * 2; i++) {
        const cycle1 = naikValues.slice(i, i + cycleLength);
        const cycle2 = naikValues.slice(i + cycleLength, i + cycleLength * 2);
        
        const isMatch = JSON.stringify(cycle1) === JSON.stringify(cycle2);
        if (isMatch) {
            matchCount++;
            cycles.push(cycle1);
        }
    }
    
    const confidence = cycles.length > 0 ? 
        (matchCount / Math.floor(naikValues.length / cycleLength)) * 100 : 0;
    
    return {
        method: `Cycle ${cycleLength}`,
        pattern: cycles.length > 0 ? cycles[0] : null,
        confidence: confidence,
        details: cycles.length > 0 ? 
            `Pattern berulang setiap ${cycleLength} data: [${cycles[0].join(', ')}] (${confidence.toFixed(1)}% match)` :
            `Tidak ditemukan cycle ${cycleLength}`
    };
}

function analyzeAlternatingPattern(naikValues) {
    if (naikValues.length < 4) {
        return {
            method: 'Alternating',
            pattern: null,
            confidence: 0,
            details: 'Data tidak cukup untuk alternating pattern'
        };
    }
    
    // Cek pattern A-B-A-B
    let abMatch = true;
    for (let i = 2; i < naikValues.length; i++) {
        if (naikValues[i] !== naikValues[i % 2]) {
            abMatch = false;
            break;
        }
    }
    
    if (abMatch) {
        return {
            method: 'Alternating',
            pattern: [naikValues[0], naikValues[1]],
            confidence: 90,
            details: `Pattern alternating: ${naikValues[0]}, ${naikValues[1]}`
        };
    }
    
    return {
        method: 'Alternating',
        pattern: null,
        confidence: 0,
        details: 'Tidak ditemukan alternating pattern'
    };
}

function analyzeSequencePattern(parsedData) {
    // Analisis pattern untuk sequence lengkap
    const sequences = [];
    
    for (let i = 0; i < parsedData.length - 1; i++) {
        const sequence = [];
        for (let digit = 0; digit < parsedData[0].digits.length; digit++) {
            const naik = (parsedData[i + 1].digits[digit] - parsedData[i].digits[digit] + 10) % 10;
            sequence.push(naik);
        }
        sequences.push(sequence);
    }
    
    // Cari sequence pattern
    const sequenceAnalysis = analyzeExactSequenceMatch(sequences);
    
    return {
        type: 'Sequence Analysis',
        sequences: sequences,
        analysis: sequenceAnalysis
    };
}

function analyzeExactSequenceMatch(sequences) {
    const firstSequence = sequences[0];
    const allSame = sequences.every(seq => JSON.stringify(seq) === JSON.stringify(firstSequence));
    
    return {
        method: 'Exact Sequence Match',
        pattern: allSame ? firstSequence : null,
        confidence: allSame ? 100 : 0,
        details: allSame ? 
            `Semua sequence sama: [${firstSequence.join(', ')}]` :
            'Sequence tidak konsisten'
    };
}

function generateSummary(analyses) {
    const validPatterns = analyses.filter(a => a.bestPattern.confidence >= 80);
    const isFullyConsistent = validPatterns.length === analyses.length;
    
    return {
        isFullyConsistent: isFullyConsistent,
        validPatterns: validPatterns.length,
        totalDigits: analyses.length,
        recommendedPattern: isFullyConsistent ? 
            analyses.map(a => a.bestPattern.pattern) : null,
        confidence: isFullyConsistent ? 
            Math.min(...analyses.map(a => a.bestPattern.confidence)) : 0
    };
}

function displayResults(results) {
    const container = document.getElementById('resultsContainer');
    let html = '';
    
    // Summary
    html += `<div class="result-item ${results.summary.isFullyConsistent ? 'result-valid' : 'result-invalid'}">`;
    html += `<h3>üìä SUMMARY</h3>`;
    html += `<div><strong>Status:</strong> ${results.summary.isFullyConsistent ? '‚úÖ PATTERN KONSISTEN' : '‚ö†Ô∏è PATTERN TIDAK KONSISTEN'}</div>`;
    html += `<div><strong>Pattern yang Valid:</strong> ${results.summary.validPatterns}/${results.summary.totalDigits} digit</div>`;
    
    if (results.summary.recommendedPattern) {
        html += `<div><strong>Recommended Pattern:</strong> [${results.summary.recommendedPattern.join(', ')}]</div>`;
        html += `<div><strong>Confidence:</strong> ${results.summary.confidence.toFixed(1)}%</div>`;
    }
    html += `</div>`;
    
    // Detail per digit
    results.digitAnalyses.forEach(analysis => {
        const isValid = analysis.bestPattern.confidence >= 80;
        html += `<div class="result-item ${isValid ? 'result-valid' : 'result-invalid'}">`;
        html += `<h3>Digit ${analysis.digit}</h3>`;
        html += `<div><strong>Nilai Naik:</strong> [${analysis.naikValues.join(', ')}]</div>`;
        html += `<div><strong>Best Pattern:</strong> ${analysis.bestPattern.pattern !== null ? analysis.bestPattern.pattern : 'Tidak ditemukan'}</div>`;
        html += `<div><strong>Method:</strong> ${analysis.bestPattern.method}</div>`;
        html += `<div><strong>Confidence:</strong> ${analysis.bestPattern.confidence.toFixed(1)}%</div>`;
        
        html += `<div class="pattern-details">`;
        html += `<strong>Detail Analisis:</strong><br>`;
        analysis.details.slice(0, 5).forEach(detail => {
            html += `${detail.from}‚Üí${detail.to}: ${detail.current}‚Üí${detail.next} (naik ${detail.naik})<br>`;
        });
        if (analysis.details.length > 5) {
            html += `... dan ${analysis.details.length - 5} data lainnya<br>`;
        }
        html += `</div>`;
        
        html += `</div>`;
    });
    
    // Sequence analysis
    html += `<div class="result-item ${results.sequenceAnalysis.analysis.confidence >= 80 ? 'result-valid' : 'result-invalid'}">`;
    html += `<h3>Sequence Analysis</h3>`;
    html += `<div><strong>Method:</strong> ${results.sequenceAnalysis.analysis.method}</div>`;
    html += `<div><strong>Pattern:</strong> ${results.sequenceAnalysis.analysis.pattern ? '[' + results.sequenceAnalysis.analysis.pattern.join(', ') + ']' : 'Tidak ditemukan'}</div>`;
    html += `<div><strong>Confidence:</strong> ${results.sequenceAnalysis.analysis.confidence.toFixed(1)}%</div>`;
    html += `</div>`;
    
    container.innerHTML = html;
    document.getElementById('resultsSection').style.display = 'block';
}

function updateProgress(percent) {
    document.getElementById('progressFill').style.width = percent + '%';
}

function showInfo(message, type) {
    const infoDiv = document.getElementById('info');
    infoDiv.textContent = message;
    infoDiv.style.background = type === 'error' ? '#ffebee' : 
                             type === 'success' ? '#e8f5e8' : '#e3f2fd';
    infoDiv.style.color = type === 'error' ? '#c62828' :
                        type === 'success' ? '#2e7d32' : '#1565c0';
}

function clearAll() {
    document.getElementById('inputData').value = '';
    document.getElementById('resultsSection').style.display = 'none';
    document.getElementById('progressBar').style.display = 'none';
    showInfo('Masukkan data, lalu klik ANALISIS PATTERN', 'info');
}

// Event listeners
document.getElementById('inputData').addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.key === 'Enter') {
        analyzePattern();
    }
});
</script>
</body>
</html>
