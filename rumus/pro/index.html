<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kalkulator Mistik Pro - Brute Force Pattern</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family: Arial,sans-serif; background: linear-gradient(135deg,#667eea,#764ba2); min-height:100vh; padding:20px; }
.container { max-width:1400px; margin:0 auto; background:white; border-radius:15px; padding:30px; box-shadow:0 10px 30px rgba(0,0,0,0.2); }
h1 { text-align:center; color:#333; margin-bottom:10px; }
.subtitle { text-align:center; color:#666; font-size:14px; margin-bottom:30px; }

.input-section { background:#f8f9fa; padding:25px; border-radius:10px; border:2px solid #e9ecef; margin-bottom:25px; }
.section-title { color:#333; margin-bottom:20px; font-size:18px; font-weight:bold; }
.data-input { margin-bottom:20px; }
.data-input textarea { width:100%; height:400px; padding:15px; border:2px solid #ddd; border-radius:8px; font-size:14px; resize:vertical; font-family:monospace; line-height:1.5; }
.data-input textarea:focus { border-color:#667eea; outline:none; }
.button-group { display:flex; gap:15px; margin-bottom:20px; }
button { flex:1; padding:15px; border:none; border-radius:8px; font-size:16px; font-weight:bold; cursor:pointer; transition:all 0.3s; }
.btn-calculate { background:#4CAF50;color:white; }
.btn-clear { background:#f44336;color:white; }
button:hover { opacity:0.9; transform:translateY(-2px); }
.info { background:#e3f2fd; padding:15px; border-radius:8px; margin-bottom:20px; text-align:center; }
.input-info { text-align:center; color:#666; font-size:14px; margin-bottom:15px; }
.progress { margin:10px 0; height:20px; background:#e0e0e0; border-radius:10px; overflow:hidden; display:none; }
.progress-bar { height:100%; background:#4CAF50; transition:width 0.3s; }
.brute-force-info { background:#fff3cd; padding:15px; border-radius:8px; margin-bottom:20px; border:1px solid #ffeaa7; display:none; }

.output-section { background:#f8f9fa; padding:25px; border-radius:10px; border:2px solid #e9ecef; margin-bottom:25px; }
.result-box { background:#2d2d2d; color:#f8f8f2; padding:20px; border-radius:8px; font-family:'Courier New',monospace; min-height:300px; white-space:pre-wrap; line-height:1.5; font-size:14px; overflow-x:auto; user-select:all; }

.pattern-analysis { background:#e8f5e8; padding:20px; border-radius:8px; margin-bottom:20px; border:1px solid #c8e6c9; }
.pattern-analysis h4 { color:#2e7d32; margin-bottom:15px; }
.pattern-item { margin-bottom:15px; padding:10px; background:#f1f8e9; border-radius:5px; }
.pattern-valid { border-left:4px solid #4CAF50; }
.pattern-invalid { border-left:4px solid #ff9800; background:#fff3e0; }

.explanation { background:#fff3cd; padding:20px; border-radius:8px; margin-top:25px; border:1px solid #ffeaa7; }
.explanation h3 { color:#856404; margin-bottom:15px; }
.explanation ul { color:#856404; padding-left:20px; }
.explanation li { margin-bottom:8px; }
</style>
</head>
<body>
<div class="container">
    <h1>üîÆ KALKULATOR MISTIK PRO</h1>
    <div class="subtitle">Brute Force Pattern Detection - [0,0] sampai [9,9]</div>
    
    <div class="input-section">
        <div class="section-title">üì• INPUT DATA & RUMUS</div>
        
        <div class="data-input">
            <textarea id="inputData" placeholder="Masukkan data dan rumus dalam format:&#10;6874 = 94 . 91 . 49 ai&#10;0489 = 83 . 35 . 49 ai&#10;...&#10;======&#10;A6ix+K8mb.(mb)&#10;A9‚ÄìC10.(ty)&#10;C8ix+E2ml.(ml)">6874 = 94 . 91 . 49 ai
0489 = 83 . 35 . 49 ai
2843 = 72 . 57 . 27 ai
3752 = 49 . 24 . 94 ai
8644 = 16 . 24 . 72 ai
2962 = 72 . 35 . 27 ai
6937 = 50 . 79 . 05 ai
0559 = 49 . 35 . 49 ai
8445 = 49 . 79 . 94 ai
2429 = 49 . 91 . 27 ai
5879 = 05 . 35 . 38 ai
9158 = 61 . 24 . 49 ai
5364 = 50 . 80 . 49 ai
2190 = 38 . 57 . 50 ai
3358 = 05 . 02 . 05 ai
1452 = 
======
A6ix+K8mb.(mb)
A9‚ÄìC10.(ty)
C8ix+E2ml.(ml)</textarea>
            <div class="input-info" id="inputInfo">Data dan rumus terdeteksi</div>
        </div>
        
        <div class="progress" id="progressBar">
            <div class="progress-bar" id="progressFill" style="width:0%"></div>
        </div>
        
        <div class="brute-force-info" id="bruteForceInfo">
            <strong>üîç BRUTE FORCE IN PROGRESS:</strong> 
            <span id="currentPattern">Testing pattern...</span> | 
            <span id="patternsTested">0/100 patterns tested</span>
        </div>
        
        <div class="button-group">
            <button class="btn-calculate" onclick="calculateWithBruteForce()">üßÆ BRUTE FORCE PATTERN</button>
            <button class="btn-clear" onclick="clearAll()">üóëÔ∏è CLEAR</button>
        </div>
        
        <div class="info" id="info">Masukkan data dan rumus, lalu klik BRUTE FORCE PATTERN</div>
        <div class="pattern-analysis" id="patternAnalysis" style="display:none;">
            <h4>üîç HASIL BRUTE FORCE PATTERN:</h4>
            <div id="patternResults"></div>
        </div>
    </div>

    <div class="output-section">
        <div class="section-title">üì§ HASIL PERHITUNGAN</div>
        <div class="result-box" id="resultOutput">
// Hasil perhitungan akan muncul di sini
// Format:
// 6874 = 94 . 91 . 49 ai
// 0489 = 83 . 35 . 49 ai  
// 2843 = 72 . 57 . 27 ai
// ...
// ======
// A6ix+K8mb.(mb) 
// A9‚ÄìC10.(ty) 
// C8ix+E2ml.(ml)
        </div>
    </div>

    <div class="explanation">
        <h3>üìù BRUTE FORCE PATTERN DETECTION:</h3>
        <ul>
            <li><strong>100 Pattern Combinations:</strong> Test semua pattern dari [0,0] sampai [9,9]</li>
            <li><strong>Auto-Stop:</strong> Berhenti otomatis ketika menemukan pattern 100% akurat</li>
            <li><strong>Real-time Progress:</strong> Lihat progress testing secara live</li>
            <li><strong>No Errors:</strong> Tidak ada error handling yang kompleks</li>
            <li><strong>Simple & Reliable:</strong> Pendekatan langsung dan dapat diandalkan</li>
        </ul>
    </div>
</div>

<script>
// Tabel konversi mistik
const mistikTables = {
    'IX': {'0':'5', '1':'6', '2':'7', '3':'8', '4':'9', '5':'0', '6':'1', '7':'2', '8':'3', '9':'4'},
    'TY': {'0':'7', '1':'4', '2':'9', '3':'6', '4':'1', '5':'8', '6':'3', '7':'0', '8':'5', '9':'2'},
    'ML': {'0':'1', '1':'0', '2':'5', '3':'8', '4':'7', '5':'2', '6':'9', '7':'4', '8':'3', '9':'6'},
    'MB': {'0':'8', '1':'7', '2':'6', '3':'9', '4':'5', '5':'4', '6':'2', '7':'1', '8':'0', '9':'3'},
    'M0': {'0':'6', '1':'5', '2':'7', '3':'8', '4':'9', '5':'1', '6':'0', '7':'2', '8':'3', '9':'4'},
    'M1': {'0':'1', '1':'0', '2':'9', '3':'8', '4':'7', '5':'6', '6':'5', '7':'4', '8':'3', '9':'2'},
    'M3': {'0':'3', '1':'2', '2':'1', '3':'0', '4':'9', '5':'8', '6':'7', '7':'6', '8':'5', '9':'4'},
    'M5': {'0':'5', '1':'4', '2':'3', '3':'2', '4':'1', '5':'0', '6':'9', '7':'8', '8':'7', '9':'6'},
    'M7': {'0':'7', '1':'6', '2':'5', '3':'4', '4':'3', '5':'2', '6':'1', '7':'0', '8':'9', '9':'8'},
    'M9': {'0':'9', '1':'8', '2':'7', '3':'6', '4':'5', '5':'4', '6':'3', '7':'2', '8':'1', '9':'0'}
};

let dataHistory = [];
let foundPatterns = [];

// Fungsi naik dalam sistem siklik 0-9
function naikSiklik(digit, steps) {
    let result = parseInt(digit);
    for (let i = 0; i < steps; i++) {
        result = (result + 1) % 10;
    }
    return result;
}

function calculateWithBruteForce() {
    const inputData = document.getElementById('inputData').value.trim();
    
    if (!inputData) {
        showInfo('Masukkan data dan rumus terlebih dahulu!', 'error');
        return;
    }
    
    try {
        showInfo('Memulai Brute Force Pattern Detection...', 'info');
        document.getElementById('progressBar').style.display = 'block';
        document.getElementById('bruteForceInfo').style.display = 'block';
        updateProgress(0);
        
        // Parse data input dan extract formulas
        const { parsedData, formulas } = parseCompleteInput(inputData);
        
        if (!parsedData || parsedData.length === 0) {
            throw new Error('Tidak ada data yang berhasil di-parse');
        }
        
        console.log('Data yang di-parse:', parsedData);
        console.log('Rumus yang ditemukan:', formulas);
        
        updateProgress(10);
        
        // Hitung BASE RESULT dengan program lama untuk semua data
        calculateBaseResults(parsedData, formulas);
        updateProgress(30);
        
        // Brute Force Pattern Detection
        const bruteForceResults = bruteForcePatternDetection(parsedData, formulas);
        foundPatterns = bruteForceResults.patterns;
        
        updateProgress(80);
        
        // Calculate untuk data yang belum lengkap
        const results = calculateMissingDataWithPatterns(parsedData, formulas, foundPatterns);
        updateProgress(90);
        
        // Display result
        displayAdvancedResult(results, formulas);
        displayBruteForceResults(bruteForceResults);
        showInfo('Brute Force Pattern Detection selesai!', 'success');
        updateProgress(100);
        
    } catch (error) {
        showInfo(`Error: ${error.message}`, 'error');
        console.error('Calculation error:', error);
    }
}

function parseCompleteInput(inputData) {
    const lines = inputData.split('\n').filter(line => line.trim());
    const parsedData = [];
    let formulas = [];
    let foundSeparator = false;
    
    for (let line of lines) {
        if (line.trim() === '======') {
            foundSeparator = true;
            continue;
        }
        
        if (!foundSeparator) {
            const match = line.match(/^(\d+)\s*=\s*(.*?)\s*$/);
            if (match) {
                const number = match[1];
                const resultsStr = match[2].trim();
                
                let results = [];
                let label = 'ai';
                
                if (resultsStr && resultsStr !== '') {
                    const parts = resultsStr.split(/\s+/);
                    let tempResults = [];
                    let tempLabel = '';
                    
                    for (let part of parts) {
                        if (part === '.') continue;
                        if (part.match(/^[a-z]+$/i)) {
                            tempLabel = part;
                        } else if (part.match(/^\d+$/)) {
                            tempResults.push(part);
                        }
                    }
                    
                    results = tempResults;
                    label = tempLabel || 'ai';
                }
                
                parsedData.push({
                    number: number,
                    results: results,
                    label: label,
                    components: extractComponents(number),
                    baseResults: []
                });
            }
        } else {
            if (line.trim() && !line.includes('======')) {
                formulas.push(line.trim());
            }
        }
    }
    
    if (!foundSeparator || formulas.length === 0) {
        formulas = ['A6ix+K8mb.(mb)', 'A9‚ÄìC10.(ty)', 'C8ix+E2ml.(ml)'];
    }
    
    return { parsedData, formulas };
}

function extractComponents(number) {
    const as = number[0];
    const cop = number[1];
    const kepala = number[2];
    const ekor = number[3];
    const jumlah = reduceToSingleDigit(parseInt(kepala) + parseInt(ekor));
    
    return { as, cop, kepala, ekor, jumlah };
}

// Hitung BASE RESULT dengan program lama
function calculateBaseResults(parsedData, formulas) {
    const reversedData = [...parsedData].reverse();
    
    for (let formulaIndex = 0; formulaIndex < formulas.length; formulaIndex++) {
        const formula = formulas[formulaIndex];
        for (let dataIndex = 0; dataIndex < reversedData.length; dataIndex++) {
            const data = reversedData[dataIndex];
            try {
                const baseResult = calculateSingleAI(formula, dataIndex, reversedData);
                if (!data.baseResults) data.baseResults = [];
                data.baseResults[formulaIndex] = baseResult;
            } catch (error) {
                console.error(`Error calculating base for ${data.number} with ${formula}:`, error);
                if (!data.baseResults) data.baseResults = [];
                data.baseResults[formulaIndex] = '';
            }
        }
    }
}

// PROGRAM LAMA - Calculate Single AI
function calculateSingleAI(formula, currentDayIndex, dataHistory) {
    let workingFormula = formula;
    
    const finalConversion = workingFormula.match(/\.\((\w+)\)/);
    if (finalConversion) {
        workingFormula = workingFormula.replace(/\.\((\w+)\)/, '');
    }
    
    const components = workingFormula.split('+');
    let total = 0;
    
    for (let component of components) {
        const value = processComponent(component.trim(), currentDayIndex, dataHistory);
        total += value;
    }
    
    if (finalConversion) {
        const table = finalConversion[1].toUpperCase();
        const converted = convertMistik(total.toString(), table);
        total = parseInt(converted);
    }
    
    const finalResult = reduceToSingleDigit(total);
    return finalResult;
}

function processComponent(component, currentDayIndex, dataHistory) {
    const match = component.match(/^([AKCEJ])(\d+)(\w*)$/);
    if (!match) {
        return 0;
    }
    
    const type = match[1];
    const dayOffset = parseInt(match[2]);
    const conversion = match[3];
    
    const targetDayIndex = currentDayIndex + (dayOffset - 1);
    
    if (targetDayIndex >= dataHistory.length) {
        return 0;
    }
    
    const data = dataHistory[targetDayIndex];
    let value;
    
    switch(type) {
        case 'A': value = parseInt(data.components.as); break;
        case 'K': value = parseInt(data.components.kepala); break;
        case 'C': value = parseInt(data.components.cop); break;
        case 'E': value = parseInt(data.components.ekor); break;
        case 'J': value = data.components.jumlah; break;
        default: value = 0;
    }
    
    if (conversion) {
        const table = conversion.toUpperCase();
        value = parseInt(convertMistik(value.toString(), table));
    }
    
    return value;
}

function convertMistik(number, table) {
    if (!mistikTables[table]) {
        return number;
    }
    
    const digit = reduceToSingleDigit(parseInt(number)).toString();
    
    if (mistikTables[table][digit] === undefined) {
        return number;
    }
    
    return mistikTables[table][digit];
}

// BRUTE FORCE PATTERN DETECTION
function bruteForcePatternDetection(parsedData, formulas) {
    const results = {
        patterns: [],
        totalTested: 0,
        perfectMatches: 0
    };
    
    // Untuk setiap rumus, cari pattern terbaik
    for (let formulaIndex = 0; formulaIndex < formulas.length; formulaIndex++) {
        const formula = formulas[formulaIndex];
        const patternResult = findBestPatternForFormula(parsedData, formula, formulaIndex);
        results.patterns.push(patternResult);
        results.totalTested += patternResult.testedPatterns;
        if (patternResult.isPerfectMatch) results.perfectMatches++;
    }
    
    return results;
}

function findBestPatternForFormula(parsedData, formula, formulaIndex) {
    // Cari data yang punya hasil untuk rumus ini
    const validData = [];
    for (let i = 0; i < parsedData.length; i++) {
        const item = parsedData[i];
        if (item.results.length > formulaIndex && 
            item.results[formulaIndex] && 
            item.results[formulaIndex] !== '') {
            validData.push(item);
        }
    }
    
    if (validData.length < 4) {
        return {
            formula: formula,
            pattern: null,
            accuracy: 0,
            isPerfectMatch: false,
            testedPatterns: 0,
            reason: `Hanya ${validData.length} data dengan hasil (minimal 4 required)`
        };
    }
    
    const digitLength = validData[0].results[formulaIndex].length;
    let bestPattern = null;
    let bestAccuracy = 0;
    let testedPatterns = 0;
    
    // Brute force semua kombinasi pattern 2 digit
    for (let p1 = 0; p1 <= 9; p1++) {
        for (let p2 = 0; p2 <= 9; p2++) {
            testedPatterns++;
            const currentPattern = [p1, p2];
            
            // Update UI progress
            if (testedPatterns % 10 === 0) {
                const progressPercent = 30 + (testedPatterns / 100) * 50;
                updateProgress(progressPercent);
                document.getElementById('currentPattern').textContent = `Testing [${p1}, ${p2}]`;
                document.getElementById('patternsTested').textContent = `${testedPatterns}/100 patterns tested`;
            }
            
            // Test pattern ini pada semua data
            let correctPredictions = 0;
            let totalTests = 0;
            
            for (let i = 0; i < validData.length; i++) {
                const data = validData[i];
                const baseResult = data.baseResults[formulaIndex];
                
                if (baseResult === '' || baseResult === undefined) continue;
                
                // Hitung prediksi dengan pattern
                let predictedResult = "";
                let currentDigit = parseInt(baseResult);
                
                for (let j = 0; j < digitLength; j++) {
                    currentDigit = naikSiklik(currentDigit, currentPattern[j]);
                    predictedResult += currentDigit.toString();
                }
                
                // Bandingkan dengan hasil actual
                const actualResult = data.results[formulaIndex];
                if (predictedResult === actualResult) {
                    correctPredictions++;
                }
                totalTests++;
            }
            
            const accuracy = totalTests > 0 ? (correctPredictions / totalTests) * 100 : 0;
            
            if (accuracy > bestAccuracy) {
                bestAccuracy = accuracy;
                bestPattern = currentPattern;
                
                // Jika menemukan pattern 100% akurat, stop langsung
                if (accuracy === 100) {
                    return {
                        formula: formula,
                        pattern: bestPattern,
                        accuracy: bestAccuracy,
                        isPerfectMatch: true,
                        testedPatterns: testedPatterns,
                        reason: `Pattern sempurna ditemukan setelah ${testedPatterns} tests`
                    };
                }
            }
        }
    }
    
    return {
        formula: formula,
        pattern: bestPattern,
        accuracy: bestAccuracy,
        isPerfectMatch: bestAccuracy === 100,
        testedPatterns: testedPatterns,
        reason: bestPattern ? 
            `Best pattern: [${bestPattern.join(', ')}] (${bestAccuracy.toFixed(1)}% accuracy)` :
            'Tidak ada pattern yang cocok'
    };
}

function calculateMissingDataWithPatterns(parsedData, formulas, patterns) {
    const results = [...parsedData];
    
    for (let data of results) {
        // Pastikan array results cukup panjang
        while (data.results.length < formulas.length) {
            data.results.push('');
        }
        
        // Hitung hasil untuk setiap formula yang belum ada
        for (let i = 0; i < formulas.length; i++) {
            if (!data.results[i] || data.results[i] === '') {
                const pattern = patterns[i];
                if (pattern && pattern.pattern && pattern.accuracy >= 80) {
                    const calculatedResult = calculateWithSpecificPattern(data, formulas[i], pattern.pattern, i);
                    data.results[i] = calculatedResult;
                }
            }
        }
    }
    
    return results;
}

function calculateWithSpecificPattern(data, formula, pattern, formulaIndex) {
    try {
        const baseResult = data.baseResults[formulaIndex];
        
        if (!baseResult && baseResult !== 0) {
            return "";
        }
        
        let finalResult = "";
        let currentDigit = parseInt(baseResult);
        
        for (let i = 0; i < pattern.length; i++) {
            currentDigit = naikSiklik(currentDigit, pattern[i]);
            finalResult += currentDigit.toString();
        }
        
        return finalResult;
        
    } catch (error) {
        return "";
    }
}

function displayBruteForceResults(results) {
    const patternAnalysis = document.getElementById('patternAnalysis');
    const patternResults = document.getElementById('patternResults');
    
    let html = '';
    
    results.patterns.forEach((pattern, index) => {
        const statusClass = pattern.isPerfectMatch ? 'pattern-valid' : 
                           pattern.accuracy >= 80 ? 'pattern-valid' : 'pattern-invalid';
        const statusIcon = pattern.isPerfectMatch ? 'üéØ' : 
                          pattern.accuracy >= 80 ? '‚úÖ' : '‚ö†Ô∏è';
        
        html += `<div class="pattern-item ${statusClass}">`;
        html += `<div><strong>${statusIcon} Rumus ${index + 1}:</strong> ${pattern.formula}</div>`;
        html += `<div><strong>Pattern:</strong> ${pattern.pattern ? '[' + pattern.pattern.join(', ') + ']' : 'Tidak ditemukan'}</div>`;
        html += `<div><strong>Accuracy:</strong> ${pattern.accuracy.toFixed(1)}%</div>`;
        html += `<div><strong>Status:</strong> ${pattern.reason}</div>`;
        html += `<div><strong>Patterns Tested:</strong> ${pattern.testedPatterns}</div>`;
        html += `</div>`;
    });
    
    html += `<div class="pattern-item pattern-valid">`;
    html += `<div><strong>üìä SUMMARY:</strong></div>`;
    html += `<div><strong>Total Patterns Tested:</strong> ${results.totalTested}</div>`;
    html += `<div><strong>Perfect Matches:</strong> ${results.perfectMatches}/${results.patterns.length}</div>`;
    html += `</div>`;
    
    patternResults.innerHTML = html;
    patternAnalysis.style.display = 'block';
}

function displayAdvancedResult(results, formulas) {
    const output = document.getElementById('resultOutput');
    let outputText = '';
    
    results.forEach(result => {
        outputText += `${result.number} = `;
        if (result.results.length > 0) {
            const validResults = result.results.slice(0, formulas.length).filter(r => r !== '');
            outputText += validResults.join(' . ');
            if (result.label && validResults.length > 0) {
                outputText += ` ${result.label}`;
            }
        }
        outputText += '\n';
    });
    
    outputText += '======\n';
    formulas.forEach(formula => {
        outputText += `${formula}\n`;
    });
    
    output.textContent = outputText;
}

function reduceToSingleDigit(num) {
    let result = num;
    while (result > 9) {
        result = result.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
    }
    return result;
}

function updateProgress(percent) {
    document.getElementById('progressFill').style.width = percent + '%';
}

function showInfo(message, type) {
    const infoDiv = document.getElementById('info');
    infoDiv.textContent = message;
    infoDiv.style.background = type === 'error' ? '#ffebee' : 
                             type === 'success' ? '#e8f5e8' : '#e3f2fd';
    infoDiv.style.color = type === 'error' ? '#c62828' :
                        type === 'success' ? '#2e7d32' : '#1565c0';
}

function clearAll() {
    document.getElementById('inputData').value = `6874 = 94 . 91 . 49 ai
0489 = 83 . 35 . 49 ai
2843 = 72 . 57 . 27 ai
3752 = 49 . 24 . 94 ai
8644 = 16 . 24 . 72 ai
2962 = 72 . 35 . 27 ai
6937 = 50 . 79 . 05 ai
0559 = 49 . 35 . 49 ai
8445 = 49 . 79 . 94 ai
2429 = 49 . 91 . 27 ai
5879 = 05 . 35 . 38 ai
9158 = 61 . 24 . 49 ai
5364 = 50 . 80 . 49 ai
2190 = 38 . 57 . 50 ai
3358 = 05 . 02 . 05 ai
1452 = 
======
A6ix+K8mb.(mb)
A9‚ÄìC10.(ty)
C8ix+E2ml.(ml)`;
    document.getElementById('resultOutput').textContent = `// Hasil perhitungan akan muncul di sini
// Format:
// 6874 = 94 . 91 . 49 ai
// 0489 = 83 . 35 . 49 ai  
// 2843 = 72 . 57 . 27 ai
// ...
// ======
// A6ix+K8mb.(mb) 
// A9‚ÄìC10.(ty) 
// C8ix+E2ml.(ml)`;
    document.getElementById('info').textContent = 'Masukkan data dan rumus, lalu klik BRUTE FORCE PATTERN';
    document.getElementById('inputInfo').textContent = 'Data dan rumus terdeteksi';
    document.getElementById('patternAnalysis').style.display = 'none';
    document.getElementById('progressBar').style.display = 'none';
    document.getElementById('bruteForceInfo').style.display = 'none';
    dataHistory = [];
    foundPatterns = [];
}

// Event listeners
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('inputData').addEventListener('input', updateInputInfo);
    updateInputInfo();
});

function updateInputInfo() {
    const input = document.getElementById('inputData').value.trim();
    const lines = input.split('\n').filter(line => line.trim());
    const dataCount = lines.filter(line => line.match(/^\d+\s*=/)).length;
    const hasFormulas = input.includes('======');
    
    let info = `${dataCount} data terdeteksi`;
    if (hasFormulas) {
        info += ' + rumus';
    }
    
    document.getElementById('inputInfo').textContent = info;
}

document.getElementById('inputData').addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.key === 'Enter') {
        calculateWithBruteForce();
    }
});
</script>
</body>
</html>
